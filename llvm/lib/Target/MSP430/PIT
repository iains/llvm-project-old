def CMP8ri0 : CGForm8<0x9, DstReg, R3Zero, Size2Bytes,
                      (outs), (ins GR8:$src),
                   "cmp.b\t{#0, $src}",
                   [(MSP430cmp GR8:$src, 0), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def CMP8ri1 : CGForm8<0x9, DstReg, R3One, Size2Bytes,
                      (outs), (ins GR8:$src),
                   "cmp.b\t{#1, $src}",
                   [(MSP430cmp GR8:$src, 1), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

def CMP8ri2 : CGForm8<0x9, DstReg, R3Two, Size2Bytes,
                      (outs), (ins GR8:$src),
                   "cmp.b\t{#2, $src}",
                   [(MSP430cmp GR8:$src, 2), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

def CMP8ri4 : CGForm8<0x9, DstReg, R2Four, Size2Bytes,
                      (outs), (ins GR8:$src),
                   "cmp.b\t{#4, $src}",
                   [(MSP430cmp GR8:$src, 4), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

def CMP8ri8 : CGForm8<0x9, DstReg, R2Eight, Size2Bytes,
                      (outs), (ins GR8:$src),
                   "cmp.b\t{#8, $src}",
                   [(MSP430cmp GR8:$src, 8), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

def CMP8rim1 : CGForm8<0x9, DstReg, R3MOne, Size2Bytes,
                      (outs), (ins GR8:$src),
                   "cmp.b\t{#-1, $src}",
                   [(MSP430cmp GR8:$src, -1), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }
def CMP16ri0 : CGForm16<0x9, DstReg, R3Zero, Size2Bytes,
                       (outs), (ins GR16:$src),
                       "cmp.w\t{#0, $src}",
                       [(MSP430cmp GR16:$src, 0), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def CMP16ri1 : CGForm16<0x9, DstReg, R3One, Size2Bytes,
                      (outs), (ins GR16:$src),
                   "cmp.w\t{#1, $src}",
                   [(MSP430cmp GR16:$src, 1), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def CMP16ri2 : CGForm16<0x9, DstReg, R3Two, Size2Bytes,
                      (outs), (ins GR16:$src),
                   "cmp.w\t{#2, $src}",
                   [(MSP430cmp GR16:$src, 2), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

def CMP16ri4 : CGForm16<0x9, DstReg, R2Four, Size2Bytes,
                      (outs), (ins GR16:$src),
                   "cmp.w\t{#4, $src}",
                   [(MSP430cmp GR16:$src, 4), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

def CMP16ri8 : CGForm16<0x9, DstReg, R2Eight, Size2Bytes,
                      (outs), (ins GR16:$src),
                   "cmp.w\t{#8, $src}",
                   [(MSP430cmp GR16:$src, 8), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

def CMP16rim1 : CGForm16<0x9, DstReg, R3MOne, Size2Bytes,
                      (outs), (ins GR16:$src),
                   "cmp.w\t{#-1, $src}",
                   [(MSP430cmp GR16:$src, -1), (implicit SR)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }


multiclass SmallImm<bits<4> opc, string rAsm, SDNode opnode> {
  let Constraints = "$src = $dst" in {
  def 8ri0 : CGForm8<opc, DstReg, R3Zero, Size2Bytes,
                      (outs GR8:$dst), (ins GR8:$src),
                   rAsm#".b\t{#0, $dst}",
                   [(set GR8:$dst, (opnode GR8:$src, 0))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

  def 8ri1 : CGForm8<opc, DstReg, R3One, Size2Bytes,
                      (outs GR8:$dst), (ins GR8:$src),
                   rAsm#".b\t{#1, $dst}",
                   [(set GR8:$dst, (opnode GR8:$src, 1))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

  def 8ri2 : CGForm8<opc, DstReg, R3Two, Size2Bytes,
                      (outs GR8:$dst), (ins GR8:$src),
                   rAsm#".b\t{#2, $dst}",
                   [(set GR8:$dst, (opnode GR8:$src, 2))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

  def 8ri4 : CGForm8<opc, DstReg, R2Four, Size2Bytes,
                      (outs GR8:$dst), (ins GR8:$src),
                   rAsm#".b\t{#4, $dst}",
                   [(set GR8:$dst, (opnode GR8:$src, 4))]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

  def 8ri8 : CGForm8<opc, DstReg, R2Eight, Size2Bytes,
                      (outs GR8:$dst), (ins GR8:$src),
                   rAsm#".b\t{#8, $dst}",
                   [(set GR8:$dst, (opnode GR8:$src, 8))]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

  def 8rim1 : CGForm8<opc, DstReg, R3MOne, Size2Bytes,
                      (outs GR8:$dst), (ins GR8:$src),
                   rAsm#".b\t{#-1, $dst}",
                   [(set GR8:$dst, (opnode GR8:$src, -1))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }

  def 16ri0 : CGForm16<opc, DstReg, R3Zero, Size2Bytes,
                      (outs GR16:$dst), (ins GR16:$src),
                   rAsm#".w\t{#0, $dst}",
                   [(set GR16:$dst, (opnode GR16:$src, 0))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

  def 16ri1 : CGForm16<opc, DstReg, R3One, Size2Bytes,
                      (outs GR16:$dst), (ins GR16:$src),
                   rAsm#".w\t{#1, $dst}",
                   [(set GR16:$dst, (opnode GR16:$src, 1))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

  def 16ri2 : CGForm16<opc, DstReg, R3Two, Size2Bytes,
                      (outs GR16:$dst), (ins GR16:$src),
                   rAsm#".w\t{#2, $dst}",
                   [(set GR16:$dst, (opnode GR16:$src, 2))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

  def 16ri4 : CGForm16<opc, DstReg, R2Four, Size2Bytes,
                      (outs GR16:$dst), (ins GR16:$src),
                   rAsm#".w\t{#4, $dst}",
                   [(set GR16:$dst, (opnode GR16:$src, 4))]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

  def 16ri8 : CGForm16<opc, DstReg, R2Eight, Size2Bytes,
                      (outs GR16:$dst), (ins GR16:$src),
                   rAsm#".w\t{#8, $dst}",
                   [(set GR16:$dst, (opnode GR16:$src, 8))]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

  def 16rim1 : CGForm16<opc, DstReg, R3MOne, Size2Bytes,
                      (outs GR16:$dst), (ins GR16:$src),
                   rAsm#".w\t{#-1, $dst}",
                   [(set GR16:$dst, (opnode GR16:$src, -1))]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }
  } // src == dst
}



def MOV8ri0 : CGForm8<0x4, DstReg, R3Zero, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#0, $dst}",
                   [(set GR8:$dst, 0)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def MOV8ri1 : CGForm8<0x4, DstReg, R3One, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#1, $dst}",
                   [(set GR8:$dst, 1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

def MOV8ri2 : CGForm8<0x4, DstReg, R3Two, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#2, $dst}",
                   [(set GR8:$dst, 2)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

def MOV8ri4 : CGForm8<0x4, DstReg, R2Four, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#4, $dst}",
                   [(set GR8:$dst, 4)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

def MOV8ri8 : CGForm8<0x4, DstReg, R2Eight, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#8, $dst}",
                   [(set GR8:$dst, 8)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

def MOV8rim1 : CGForm8<0x4, DstReg, R3MOne, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#-1, $dst}",
                   [(set GR8:$dst, -1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }
def MOV16ri0 : CGForm16<0x4, DstReg, R3Zero, Size2Bytes,
                       (outs GR16:$dst), (ins),
                       "mov.w\t{#0, $dst}",
                       [(set GR16:$dst, 0)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def MOV16ri1 : CGForm16<0x4, DstReg, R3One, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#1, $dst}",
                   [(set GR16:$dst, 1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def MOV16ri2 : CGForm16<0x4, DstReg, R3Two, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#2, $dst}",
                   [(set GR16:$dst, 2)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

def MOV16ri4 : CGForm16<0x4, DstReg, R2Four, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#4, $dst}",
                   [(set GR16:$dst, 4)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

def MOV16ri8 : CGForm16<0x4, DstReg, R2Eight, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#8, $dst}",
                   [(set GR16:$dst, 8)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

def MOV16rim1 : CGForm16<0x4, DstReg, R3MOne, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#-1, $dst}",
                   [(set GR16:$dst, -1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }



=====


let isCommutable = 1 in { // X = ADD Y, Z  == X = ADD Z, Y

def ADD8rr  : I8rr<0x5,
                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                   "add.b\t{$src2, $dst}",
                   [(set GR8:$dst, (add GR8:$src, GR8:$src2)),
                    (implicit SR)]>;
def ADD16rr : I16rr<0x5,
                    (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                    "add.w\t{$src2, $dst}",
                    [(set GR16:$dst, (add GR16:$src, GR16:$src2)),
                     (implicit SR)]>;
}

def ADD8rm  : I8rm<0x5,
                   (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                   "add.b\t{$src2, $dst}",
                   [(set GR8:$dst, (add GR8:$src, (load addr:$src2))),
                    (implicit SR)]>;
def ADD16rm : I16rm<0x5,
                    (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                    "add.w\t{$src2, $dst}",
                    [(set GR16:$dst, (add GR16:$src, (load addr:$src2))),
                     (implicit SR)]>;

let mayLoad = 1, hasExtraDefRegAllocReq = 1, 
Constraints = "$base = $base_wb, $src = $dst" in {
def ADD8rm_POST : IForm8<0x5, DstReg, SrcPostInc, Size2Bytes,
                         (outs GR8:$dst, GR16:$base_wb),
                         (ins GR8:$src, GR16:$base),
                         "add.b\t{@$base+, $dst}", []>;
def ADD16rm_POST : IForm16<0x5, DstReg, SrcPostInc, Size2Bytes,
                           (outs GR16:$dst, GR16:$base_wb),
                           (ins GR16:$src, GR16:$base),
                          "add.w\t{@$base+, $dst}", []>;
}


def ADD8ri  : I8ri<0x5,
                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                   "add.b\t{$src2, $dst}",
                   [(set GR8:$dst, (add GR8:$src, imm:$src2)),
                    (implicit SR)]>;
def ADD16ri : I16ri<0x5,
                    (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                    "add.w\t{$src2, $dst}",
                    [(set GR16:$dst, (add GR16:$src, imm:$src2)),
                     (implicit SR)]>;

let Constraints = "" in {
def ADD8mr  : I8mr<0x5,
                   (outs), (ins memdst:$dst, GR8:$src),
                   "add.b\t{$src, $dst}",
                   [(store (add (load addr:$dst), GR8:$src), addr:$dst),
                    (implicit SR)]>;
def ADD16mr : I16mr<0x5,
                    (outs), (ins memdst:$dst, GR16:$src),
                    "add.w\t{$src, $dst}",
                    [(store (add (load addr:$dst), GR16:$src), addr:$dst),
                     (implicit SR)]>;

def ADD8mi  : I8mi<0x5,
                   (outs), (ins memdst:$dst, i8imm:$src),
                   "add.b\t{$src, $dst}",
                   [(store (add (load addr:$dst), (i8 imm:$src)), addr:$dst),
                    (implicit SR)]>;
def ADD16mi : I16mi<0x5,
                    (outs), (ins memdst:$dst, i16imm:$src),
                    "add.w\t{$src, $dst}",
                    [(store (add (load addr:$dst), (i16 imm:$src)), addr:$dst),
                     (implicit SR)]>;

def ADD8mm  : I8mm<0x5,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "add.b\t{$src, $dst}",
                   [(store (add (load addr:$dst), 
                                (i8 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
def ADD16mm : I16mm<0x5,
                    (outs), (ins memdst:$dst, memsrc:$src),
                    "add.w\t{$src, $dst}",
                    [(store (add (load addr:$dst), 
                                  (i16 (load addr:$src))), addr:$dst),
                     (implicit SR)]>;
}

===
let isCommutable = 1 in { // X = ADDC Y, Z  == X = ADDC Z, Y
def ADC8rr  : I8rr<0x6,
                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                   "addc.b\t{$src2, $dst}",
                   [(set GR8:$dst, (adde GR8:$src, GR8:$src2)),
                    (implicit SR)]>;
def ADC16rr : I16rr<0x6,
                    (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                    "addc.w\t{$src2, $dst}",
                    [(set GR16:$dst, (adde GR16:$src, GR16:$src2)),
                     (implicit SR)]>;
} // isCommutable

def ADC8ri  : I8ri<0x6,
                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                   "addc.b\t{$src2, $dst}",
                   [(set GR8:$dst, (adde GR8:$src, imm:$src2)),
                    (implicit SR)]>;
def ADC16ri : I16ri<0x6,
                    (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                    "addc.w\t{$src2, $dst}",
                    [(set GR16:$dst, (adde GR16:$src, imm:$src2)),
                     (implicit SR)]>;

def ADC8rm  : I8rm<0x6,
                   (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                   "addc.b\t{$src2, $dst}",
                   [(set GR8:$dst, (adde GR8:$src, (load addr:$src2))),
                    (implicit SR)]>;
def ADC16rm : I16rm<0x6,
                    (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                    "addc.w\t{$src2, $dst}",
                    [(set GR16:$dst, (adde GR16:$src, (load addr:$src2))),
                     (implicit SR)]>;

let Constraints = "" in {
def ADC8mr  : I8mr<0x6,
                   (outs), (ins memdst:$dst, GR8:$src),
                   "addc.b\t{$src, $dst}",
                   [(store (adde (load addr:$dst), GR8:$src), addr:$dst),
                    (implicit SR)]>;
def ADC16mr : I16mr<0x6,
                    (outs), (ins memdst:$dst, GR16:$src),
                    "addc.w\t{$src, $dst}",
                    [(store (adde (load addr:$dst), GR16:$src), addr:$dst),
                     (implicit SR)]>;

def ADC8mi  : I8mi<0x6,
                   (outs), (ins memdst:$dst, i8imm:$src),
                   "addc.b\t{$src, $dst}",
                   [(store (adde (load addr:$dst), (i8 imm:$src)), addr:$dst),
                    (implicit SR)]>;
def ADC16mi : I16mi<0x6,
                    (outs), (ins memdst:$dst, i16imm:$src),
                    "addc.w\t{$src, $dst}",
                    [(store (adde (load addr:$dst), (i16 imm:$src)), addr:$dst),
                     (implicit SR)]>;

def ADC8mm  : I8mm<0x6,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "addc.b\t{$src, $dst}",
                   [(store (adde (load addr:$dst), 
                                 (i8 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
def ADC16mm : I8mm<0x6,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "addc.w\t{$src, $dst}",
                   [(store (adde (load addr:$dst), 
                                 (i16 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
}
let isCommutable = 1 in { // X = AND Y, Z  == X = AND Z, Y
def AND8rr  : I8rr<0xF,
                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                   "and.b\t{$src2, $dst}",
                   [(set GR8:$dst, (and GR8:$src, GR8:$src2)),
                    (implicit SR)]>;
def AND16rr : I16rr<0xF,
                    (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                    "and.w\t{$src2, $dst}",
                    [(set GR16:$dst, (and GR16:$src, GR16:$src2)),
                     (implicit SR)]>;
}

def AND8ri  : I8ri<0xF,
                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                   "and.b\t{$src2, $dst}",
                   [(set GR8:$dst, (and GR8:$src, imm:$src2)),
                    (implicit SR)]>;
def AND16ri : I16ri<0xF,
                    (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                    "and.w\t{$src2, $dst}",
                    [(set GR16:$dst, (and GR16:$src, imm:$src2)),
                     (implicit SR)]>;

def AND8rm  : I8rm<0xF,
                   (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                   "and.b\t{$src2, $dst}",
                   [(set GR8:$dst, (and GR8:$src, (load addr:$src2))),
                    (implicit SR)]>;
def AND16rm : I16rm<0xF,
                    (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                    "and.w\t{$src2, $dst}",
                    [(set GR16:$dst, (and GR16:$src, (load addr:$src2))),
                     (implicit SR)]>;

let mayLoad = 1, hasExtraDefRegAllocReq = 1, 
Constraints = "$base = $base_wb, $src = $dst" in {
def AND8rm_POST : IForm8<0xF, DstReg, SrcPostInc, Size2Bytes,
                         (outs GR8:$dst, GR16:$base_wb),
                         (ins GR8:$src, GR16:$base),
                         "and.b\t{@$base+, $dst}", []>;
def AND16rm_POST : IForm16<0xF, DstReg, SrcPostInc, Size2Bytes,
                           (outs GR16:$dst, GR16:$base_wb),
                           (ins GR16:$src, GR16:$base),
                           "and.w\t{@$base+, $dst}", []>;
}

let Constraints = "" in {
def AND8mr  : I8mr<0xF,
                   (outs), (ins memdst:$dst, GR8:$src),
                   "and.b\t{$src, $dst}",
                   [(store (and (load addr:$dst), GR8:$src), addr:$dst),
                    (implicit SR)]>;
def AND16mr : I16mr<0xF,
                    (outs), (ins memdst:$dst, GR16:$src),
                    "and.w\t{$src, $dst}",
                    [(store (and (load addr:$dst), GR16:$src), addr:$dst),
                     (implicit SR)]>;

def AND8mi  : I8mi<0xF,
                   (outs), (ins memdst:$dst, i8imm:$src),
                   "and.b\t{$src, $dst}",
                   [(store (and (load addr:$dst), (i8 imm:$src)), addr:$dst),
                    (implicit SR)]>;
def AND16mi : I16mi<0xF,
                    (outs), (ins memdst:$dst, i16imm:$src),
                    "and.w\t{$src, $dst}",
                    [(store (and (load addr:$dst), (i16 imm:$src)), addr:$dst),
                     (implicit SR)]>;

def AND8mm  : I8mm<0xF,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "and.b\t{$src, $dst}",
                   [(store (and (load addr:$dst), 
                                (i8 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
def AND16mm : I16mm<0xF,
                    (outs), (ins memdst:$dst, memsrc:$src),
                    "and.w\t{$src, $dst}",
                    [(store (and (load addr:$dst), 
                                 (i16 (load addr:$src))), addr:$dst),
                     (implicit SR)]>;
}
let isCommutable = 1 in { // X = OR Y, Z  == X = OR Z, Y
def OR8rr  : I8rr<0xD,
                  (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                  "bis.b\t{$src2, $dst}",
                  [(set GR8:$dst, (or GR8:$src, GR8:$src2))]>;
def OR16rr : I16rr<0xD,
                   (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                   "bis.w\t{$src2, $dst}",
                   [(set GR16:$dst, (or GR16:$src, GR16:$src2))]>;
}

def OR8ri  : I8ri<0xD,
                  (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                  "bis.b\t{$src2, $dst}",
                  [(set GR8:$dst, (or GR8:$src, imm:$src2))]>;
def OR16ri : I16ri<0xD,
                   (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                   "bis.w\t{$src2, $dst}",
                   [(set GR16:$dst, (or GR16:$src, imm:$src2))]>;

def OR8rm  : I8rm<0xD,
                  (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                  "bis.b\t{$src2, $dst}",
                  [(set GR8:$dst, (or GR8:$src, (load addr:$src2)))]>;
def OR16rm : I16rm<0xD,
                   (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                   "bis.w\t{$src2, $dst}",
                   [(set GR16:$dst, (or GR16:$src, (load addr:$src2)))]>;

let mayLoad = 1, hasExtraDefRegAllocReq = 1, 
Constraints = "$base = $base_wb, $src = $dst" in {
def OR8rm_POST : IForm8<0xD, DstReg, SrcPostInc, Size2Bytes,
                        (outs GR8:$dst, GR16:$base_wb),
                        (ins GR8:$src, GR16:$base),
                        "bis.b\t{@$base+, $dst}", []>;
def OR16rm_POST : IForm16<0xD, DstReg, SrcPostInc, Size2Bytes,
                          (outs GR16:$dst, GR16:$base_wb),
                          (ins GR16:$src, GR16:$base),
                          "bis.w\t{@$base+, $dst}", []>;
}

let Constraints = "" in {
def OR8mr  : I8mr<0xD,
                  (outs), (ins memdst:$dst, GR8:$src),
                  "bis.b\t{$src, $dst}",
                  [(store (or (load addr:$dst), GR8:$src), addr:$dst)]>;
def OR16mr : I16mr<0xD,
                   (outs), (ins memdst:$dst, GR16:$src),
                   "bis.w\t{$src, $dst}",
                   [(store (or (load addr:$dst), GR16:$src), addr:$dst)]>;

def OR8mi  : I8mi<0xD, 
                  (outs), (ins memdst:$dst, i8imm:$src),
                  "bis.b\t{$src, $dst}",
                  [(store (or (load addr:$dst), (i8 imm:$src)), addr:$dst)]>;
def OR16mi : I16mi<0xD,
                   (outs), (ins memdst:$dst, i16imm:$src),
                   "bis.w\t{$src, $dst}",
                   [(store (or (load addr:$dst), (i16 imm:$src)), addr:$dst)]>;

def OR8mm  : I8mm<0xD,
                  (outs), (ins memdst:$dst, memsrc:$src),
                  "bis.b\t{$src, $dst}",
                  [(store (or (i8 (load addr:$dst)),
                              (i8 (load addr:$src))), addr:$dst)]>;
def OR16mm : I16mm<0xD,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "bis.w\t{$src, $dst}",
                   [(store (or (i16 (load addr:$dst)),
                               (i16 (load addr:$src))), addr:$dst)]>;
}
let isCommutable = 1 in { // X = XOR Y, Z  == X = XOR Z, Y
def XOR8rr  : I8rr<0xE,
                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                   "xor.b\t{$src2, $dst}",
                   [(set GR8:$dst, (xor GR8:$src, GR8:$src2)),
                    (implicit SR)]>;
def XOR16rr : I16rr<0xE,
                    (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                    "xor.w\t{$src2, $dst}",
                    [(set GR16:$dst, (xor GR16:$src, GR16:$src2)),
                     (implicit SR)]>;
}

def XOR8ri  : I8ri<0xE,
                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                   "xor.b\t{$src2, $dst}",
                   [(set GR8:$dst, (xor GR8:$src, imm:$src2)),
                    (implicit SR)]>;
def XOR16ri : I16ri<0xE,
                    (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                    "xor.w\t{$src2, $dst}",
                    [(set GR16:$dst, (xor GR16:$src, imm:$src2)),
                     (implicit SR)]>;

def XOR8rm  : I8rm<0xE,
                   (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                   "xor.b\t{$src2, $dst}",
                   [(set GR8:$dst, (xor GR8:$src, (load addr:$src2))),
                    (implicit SR)]>;
def XOR16rm : I16rm<0xE,
                    (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                    "xor.w\t{$src2, $dst}",
                    [(set GR16:$dst, (xor GR16:$src, (load addr:$src2))),
                     (implicit SR)]>;

let mayLoad = 1, hasExtraDefRegAllocReq = 1, 
Constraints = "$base = $base_wb, $src = $dst" in {
def XOR8rm_POST : IForm8<0xE, DstReg, SrcPostInc, Size2Bytes,
                         (outs GR8:$dst, GR16:$base_wb),
                         (ins GR8:$src, GR16:$base),
                         "xor.b\t{@$base+, $dst}", []>;
def XOR16rm_POST : IForm16<0xE, DstReg, SrcPostInc, Size2Bytes,
                           (outs GR16:$dst, GR16:$base_wb),
                           (ins GR16:$src, GR16:$base),
                           "xor.w\t{@$base+, $dst}", []>;
}

let Constraints = "" in {
def XOR8mr  : I8mr<0xE,
                   (outs), (ins memdst:$dst, GR8:$src),
                   "xor.b\t{$src, $dst}",
                   [(store (xor (load addr:$dst), GR8:$src), addr:$dst),
                    (implicit SR)]>;
def XOR16mr : I16mr<0xE,
                    (outs), (ins memdst:$dst, GR16:$src),
                    "xor.w\t{$src, $dst}",
                    [(store (xor (load addr:$dst), GR16:$src), addr:$dst),
                     (implicit SR)]>;

def XOR8mi  : I8mi<0xE,
                   (outs), (ins memdst:$dst, i8imm:$src),
                   "xor.b\t{$src, $dst}",
                   [(store (xor (load addr:$dst), (i8 imm:$src)), addr:$dst),
                    (implicit SR)]>;
def XOR16mi : I16mi<0xE,
                    (outs), (ins memdst:$dst, i16imm:$src),
                    "xor.w\t{$src, $dst}",
                    [(store (xor (load addr:$dst), (i16 imm:$src)), addr:$dst),
                     (implicit SR)]>;

def XOR8mm  : I8mm<0xE,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "xor.b\t{$src, $dst}",
                   [(store (xor (load addr:$dst), (i8 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
def XOR16mm : I16mm<0xE,
                    (outs), (ins memdst:$dst, memsrc:$src),
                    "xor.w\t{$src, $dst}",
                    [(store (xor (load addr:$dst), (i16 (load addr:$src))), addr:$dst),
                     (implicit SR)]>;
}

def SUB8rr  : I8rr<0x8,
                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                   "sub.b\t{$src2, $dst}",
                   [(set GR8:$dst, (sub GR8:$src, GR8:$src2)),
                    (implicit SR)]>;
def SUB16rr : I16rr<0x8,
                    (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                    "sub.w\t{$src2, $dst}",
                    [(set GR16:$dst, (sub GR16:$src, GR16:$src2)),
                     (implicit SR)]>;

def SUB8ri  : I8ri<0x8,
                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                   "sub.b\t{$src2, $dst}",
                   [(set GR8:$dst, (sub GR8:$src, imm:$src2)),
                    (implicit SR)]>;
def SUB16ri : I16ri<0x8,
                    (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                    "sub.w\t{$src2, $dst}",
                    [(set GR16:$dst, (sub GR16:$src, imm:$src2)),
                     (implicit SR)]>;

def SUB8rm  : I8rm<0x8,
                   (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                   "sub.b\t{$src2, $dst}",
                   [(set GR8:$dst, (sub GR8:$src, (load addr:$src2))),
                    (implicit SR)]>;
def SUB16rm : I16rm<0x8,
                    (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                    "sub.w\t{$src2, $dst}",
                    [(set GR16:$dst, (sub GR16:$src, (load addr:$src2))),
                     (implicit SR)]>;

let mayLoad = 1, hasExtraDefRegAllocReq = 1, 
Constraints = "$base = $base_wb, $src = $dst" in {
def SUB8rm_POST : IForm8<0x8, DstReg, SrcPostInc, Size2Bytes,
                         (outs GR8:$dst, GR16:$base_wb),
                         (ins GR8:$src, GR16:$base),
                         "sub.b\t{@$base+, $dst}", []>;
def SUB16rm_POST : IForm16<0x8, DstReg, SrcPostInc, Size2Bytes,
                          (outs GR16:$dst, GR16:$base_wb),
                          (ins GR16:$src, GR16:$base),
                          "sub.w\t{@$base+, $dst}", []>;
}

let Constraints = "" in {
def SUB8mr  : I8mr<0x8,
                   (outs), (ins memdst:$dst, GR8:$src),
                   "sub.b\t{$src, $dst}",
                   [(store (sub (load addr:$dst), GR8:$src), addr:$dst),
                    (implicit SR)]>;
def SUB16mr : I16mr<0x8,
                    (outs), (ins memdst:$dst, GR16:$src),
                    "sub.w\t{$src, $dst}",
                    [(store (sub (load addr:$dst), GR16:$src), addr:$dst),
                     (implicit SR)]>;

def SUB8mi  : I8mi<0x8,
                   (outs), (ins memdst:$dst, i8imm:$src),
                   "sub.b\t{$src, $dst}",
                   [(store (sub (load addr:$dst), (i8 imm:$src)), addr:$dst),
                    (implicit SR)]>;
def SUB16mi : I16mi<0x8,
                    (outs), (ins memdst:$dst, i16imm:$src),
                    "sub.w\t{$src, $dst}",
                    [(store (sub (load addr:$dst), (i16 imm:$src)), addr:$dst),
                     (implicit SR)]>;

def SUB8mm  : I8mm<0x8,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "sub.b\t{$src, $dst}",
                   [(store (sub (load addr:$dst), 
                                (i8 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
def SUB16mm : I16mm<0x8,
                    (outs), (ins memdst:$dst, memsrc:$src),
                    "sub.w\t{$src, $dst}",
                    [(store (sub (load addr:$dst), 
                                 (i16 (load addr:$src))), addr:$dst),
                     (implicit SR)]>;
}

let Uses = [SR] in {
def SBC8rr  : I8rr<0x7,
                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
                   "subc.b\t{$src2, $dst}",
                   [(set GR8:$dst, (sube GR8:$src, GR8:$src2)),
                    (implicit SR)]>;
def SBC16rr : I16rr<0x7,
                    (outs GR16:$dst), (ins GR16:$src, GR16:$src2),
                    "subc.w\t{$src2, $dst}",
                    [(set GR16:$dst, (sube GR16:$src, GR16:$src2)),
                     (implicit SR)]>;

def SBC8ri  : I8ri<0x7,
                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
                   "subc.b\t{$src2, $dst}",
                   [(set GR8:$dst, (sube GR8:$src, imm:$src2)),
                    (implicit SR)]>;
def SBC16ri : I16ri<0x7,
                    (outs GR16:$dst), (ins GR16:$src, i16imm:$src2),
                    "subc.w\t{$src2, $dst}",
                    [(set GR16:$dst, (sube GR16:$src, imm:$src2)),
                     (implicit SR)]>;

def SBC8rm  : I8rm<0x7,
                   (outs GR8:$dst), (ins GR8:$src, memsrc:$src2),
                   "subc.b\t{$src2, $dst}",
                   [(set GR8:$dst, (sube GR8:$src, (load addr:$src2))),
                    (implicit SR)]>;
def SBC16rm : I16rm<0x7,
                    (outs GR16:$dst), (ins GR16:$src, memsrc:$src2),
                    "subc.w\t{$src2, $dst}",
                    [(set GR16:$dst, (sube GR16:$src, (load addr:$src2))),
                     (implicit SR)]>;

let Constraints = "" in {
def SBC8mr  : I8mr<0x7,
                   (outs), (ins memdst:$dst, GR8:$src),
                   "subc.b\t{$src, $dst}",
                  [(store (sube (load addr:$dst), GR8:$src), addr:$dst),
                   (implicit SR)]>;
def SBC16mr : I16mr<0x7,
                    (outs), (ins memdst:$dst, GR16:$src),
                    "subc.w\t{$src, $dst}",
                    [(store (sube (load addr:$dst), GR16:$src), addr:$dst),
                     (implicit SR)]>;

def SBC8mi  : I8mi<0x7,
                   (outs), (ins memdst:$dst, i8imm:$src),
                   "subc.b\t{$src, $dst}",
                   [(store (sube (load addr:$dst), (i8 imm:$src)), addr:$dst),
                    (implicit SR)]>;
def SBC16mi : I16mi<0x7,
                    (outs), (ins memdst:$dst, i16imm:$src),
                    "subc.w\t{$src, $dst}",
                    [(store (sube (load addr:$dst), (i16 imm:$src)), addr:$dst),
                     (implicit SR)]>;

def SBC8mm  : I8mm<0x7,
                   (outs), (ins memdst:$dst, memsrc:$src),
                   "subc.b\t{$src, $dst}",
                   [(store (sube (load addr:$dst),
                                 (i8 (load addr:$src))), addr:$dst),
                    (implicit SR)]>;
def SBC16mm : I16mm<0x7,
                    (outs), (ins memdst:$dst, memsrc:$src),
                    "subc.w\t{$src, $dst}",
                    [(store (sube (load addr:$dst),
                            (i16 (load addr:$src))), addr:$dst),
                     (implicit SR)]>;
}

} // Uses = [SR]

def MOV8ri0 : CGForm8<0x4, DstReg, R3Zero, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#0, $dst}",
                   [(set GR8:$dst, 0)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def MOV8ri1 : CGForm8<0x4, DstReg, R3One, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#1, $dst}",
                   [(set GR8:$dst, 1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

def MOV8ri2 : CGForm8<0x4, DstReg, R3Two, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#2, $dst}",
                   [(set GR8:$dst, 2)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

def MOV8ri4 : CGForm8<0x4, DstReg, R2Four, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#4, $dst}",
                   [(set GR8:$dst, 4)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

def MOV8ri8 : CGForm8<0x4, DstReg, R2Eight, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#8, $dst}",
                   [(set GR8:$dst, 8)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }


def MOV8rim1 : CGForm8<0x4, DstReg, R3MOne, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   "mov.b\t{#-1, $dst}",
                   [(set GR8:$dst, -1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }
def MOV16ri0 : CGForm16<0x4, DstReg, R3Zero, Size2Bytes,
                       (outs GR16:$dst), (ins),
                       "mov.w\t{#0, $dst}",
                       [(set GR16:$dst, 0)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def MOV16ri1 : CGForm16<0x4, DstReg, R3One, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#1, $dst}",
                   [(set GR16:$dst, 1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

def MOV16ri2 : CGForm16<0x4, DstReg, R3Two, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#2, $dst}",
                   [(set GR16:$dst, 2)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

def MOV16ri4 : CGForm16<0x4, DstReg, R2Four, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#4, $dst}",
                   [(set GR16:$dst, 4)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

def MOV16ri8 : CGForm16<0x4, DstReg, R2Eight, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#8, $dst}",
                   [(set GR16:$dst, 8)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

def MOV16rim1 : CGForm16<0x4, DstReg, R3MOne, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   "mov.w\t{#-1, $dst}",
                   [(set GR16:$dst, -1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }
//===----------------------------------------------------------------------===//
// Single Op Small immediate utility

multiclass SmallImmOneOp<bits<4> opc, string rAsm, SDNode opnode> {

  def 8ri0 : CGForm8<opc, DstReg, R3Zero, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   rAsm#".b\t{#0, $dst}",
                   [(opnode GR8:$dst, 0)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

  def 8ri1 : CGForm8<opc, DstReg, R3One, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   rAsm#".b\t{#1, $dst}",
                   [(opnode GR8:$dsr, 1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

  def 8ri2 : CGForm8<opc, DstReg, R3Two, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   rAsm#".b\t{#2, $dst}",
                   [(opnode GR8:$dst, 2)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

  def 8ri4 : CGForm8<opc, DstReg, R2Four, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   rAsm#".b\t{#4, $dst}",
                   [(opnode GR8:$dst, 4)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

  def 8ri8 : CGForm8<opc, DstReg, R2Eight, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   rAsm#".b\t{#8, $dst}",
                   [(opnode GR8:$dst, 8)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

  def 8rim1 : CGForm8<opc, DstReg, R3MOne, Size2Bytes,
                      (outs GR8:$dst), (ins),
                   rAsm#".b\t{#-1, $dst}",
                   [(opnode GR8:$dst, -1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }

  def 16ri0 : CGForm16<opc, DstReg, R3Zero, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   rAsm#".w\t{#0, $dst}",
                   [(opnode GR16:$dst, 0)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:0
    let Inst{3-0} = dst;
  }

  def 16ri1 : CGForm16<opc, DstReg, R3One, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   rAsm#".w\t{#1, $dst}",
                   [(opnode GR16:$dst, 1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:1
    let Inst{3-0} = dst;
  }

  def 16ri2 : CGForm16<opc, DstReg, R3Two, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   rAsm#".w\t{#2, $dst}",
                   [(opnode GR16:$dst, 2)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:2
    let Inst{3-0} = dst;
  }

  def 16ri4 : CGForm16<opc, DstReg, R2Four, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   rAsm#".w\t{#4, $dst}",
                   [(opnode GR16:$dst, 4)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:4
    let Inst{3-0} = dst;
  }

  def 16ri8 : CGForm16<opc, DstReg, R2Eight, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   rAsm#".w\t{#8, $dst}",
                   [(opnode GR16:$dst, 8)]>
  { bits<4> dst;
    let Inst{11-8} = 2; // src == r2:8
    let Inst{3-0} = dst;
  }

  def 16rim1 : CGForm16<opc, DstReg, R3MOne, Size2Bytes,
                      (outs GR16:$dst), (ins),
                   rAsm#".w\t{#-1, $dst}",
                   [(opnode GR16:$dst, -1)]>
  { bits<4> dst;
    let Inst{11-8} = 3; // src == r3:FFFF
    let Inst{3-0} = dst;
  }
}
