//===-- MSP430MCCodeEmitter.cpp - Convert MSP430 code to machine code ---===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements the MSP430MCCodeEmitter class.
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/MSP430MCTargetDesc.h"
#include "MCTargetDesc/MSP430FixupKinds.h"
#include "llvm/MC/MCCodeEmitter.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"

#include "llvm/Support/Debug.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "mccodeemitter"

namespace {
class MSP430MCCodeEmitter : public MCCodeEmitter {
  const MCInstrInfo &MCII;
  MCContext &Ctx;

public:
  MSP430MCCodeEmitter(const MCInstrInfo &mcii, MCContext &ctx)
    : MCII(mcii), Ctx(ctx) {
  }

  ~MSP430MCCodeEmitter() {}

  // OVerride MCCodeEmitter.
  void encodeInstruction(const MCInst &MI, raw_ostream &OS,
                         SmallVectorImpl<MCFixup> &Fixups,
                         const MCSubtargetInfo &STI) const override;

private:
  // Automatically generated by TableGen.
  uint64_t getBinaryCodeForInstr(const MCInst &MI,
                                 SmallVectorImpl<MCFixup> &Fixups,
                                 const MCSubtargetInfo &STI) const;

  /// getMachineOpValue - Return binary encoding of operand. If the machine
  /// operand requires relocation, record the relocation and return zero.
  unsigned getMachineOpValue(const MCInst &MI,const MCOperand &MO,
                             SmallVectorImpl<MCFixup> &Fixups,
                             const MCSubtargetInfo &STI) const;

  /// getCCEncoding - Return encoding info for "CC" operand.
  uint32_t getCCEncoding(const MCInst &MI, unsigned OpIdx,
                         SmallVectorImpl<MCFixup> &Fixups,
                         const MCSubtargetInfo &STI) const;

  /// getPCRelImmOpEncoding - branch offset encoding.
  uint32_t getPCRelImmOpEncoding(const MCInst &MI, unsigned OpIdx,
                                 SmallVectorImpl<MCFixup> &Fixups,
                                 const MCSubtargetInfo &STI) const;

  /// getMemOpEncoding - memory access encoding.
  uint32_t getMemOpEncoding(const MCInst &MI, unsigned OpIdx,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const;

  /// getR2R3ImmEncoding - Special encodings for a few small constants.
  uint32_t getR2R3ImmEncoding(const MCInst &MI, unsigned OpIdx,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const;

  /// getRegInd - Special encodings for a few small constants.
  uint32_t getRegInd(const MCInst &MI, unsigned OpIdx,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const;

};
} // end anonymous namespace

MCCodeEmitter *llvm::createMSP430MCCodeEmitter(const MCInstrInfo &MCII,
                                            const MCRegisterInfo &MRI,
                                            MCContext &Ctx) {
  return new MSP430MCCodeEmitter(MCII, Ctx);
}

void MSP430MCCodeEmitter::
encodeInstruction(const MCInst &MI, raw_ostream &OS,
                  SmallVectorImpl<MCFixup> &Fixups,
                  const MCSubtargetInfo &STI) const {

  unsigned Opcode = MI.getOpcode();
//  const MCInstrDesc &Desc = MCII.get(Opcode);
  unsigned Size = MCII.get(Opcode).getSize();
//  uint64_t TSFlags = Desc.TSFlags;
//  unsigned NumOps = Desc.getNumOperands();

//MI.dump();
//
 // for (auto &F : Fixups)
//    dbgs() << format ("%d ",F.getKind());
//dbgs() << "\n";

  uint64_t InstBits = getBinaryCodeForInstr(MI, Fixups, STI);

if (Size < 2) {
MI.dump();
dbgs() << format("Odd size - InstBits: %08llx Size = %d\n", InstBits, Size);
 Size = 2;
}
  OS << uint8_t(InstBits & 0xff);
  InstBits >>= 8;
  OS << uint8_t(InstBits & 0xff);

//  unsigned CurOp = 0;
//  unsigned Bits = 0;
  if (Size == 4) {
//    while (CurOp < NumOps) {
//      if (MI.getOperand(CurOp).isImm()) {
 //       Bits = MI.getOperand(CurOp).getImm();
//        break;
//      }
//      CurOp++;
//    }
//    OS << uint8_t(Bits & 0xff);
//    Bits >>= 8;
//    OS << uint8_t(Bits & 0xff);
    InstBits >>= 8;
    OS << uint8_t(InstBits & 0xff);
    InstBits >>= 8;
    OS << uint8_t(InstBits & 0xff);
  }
//  Bits = 0;
  if (Size == 6) {
    InstBits >>= 8;
    OS << uint8_t(InstBits & 0xff);
    InstBits >>= 8;
    OS << uint8_t(InstBits & 0xff);
  }
}

/// getMachineOpValue - Return binary encoding of operand. If the machine
/// operand requires relocation, record the relocation and return zero.
unsigned MSP430MCCodeEmitter::
getMachineOpValue(const MCInst &MI, const MCOperand &MO,
                  SmallVectorImpl<MCFixup> &Fixups,
                  const MCSubtargetInfo &STI) const {
//MI.dump();
//MO.dump();
  if (MO.isReg()) {
    unsigned Reg = MO.getReg();
    return Ctx.getRegisterInfo()->getEncodingValue(Reg);
  } else if (MO.isImm()) {
    return static_cast<unsigned>(MO.getImm());
  } else if (MO.isExpr()) {
    int64_t v;
    const MCExpr *Expr = MO.getExpr();
    if (Expr->evaluateAsAbsolute(v)) {
      return (unsigned) v;
    }
    MCFixupKind Kind = MCFixup::getKindForSize(2, false);
    Fixups.push_back(MCFixup::create(0, Expr, Kind, MI.getLoc()));

    // All of the information is in the fixup.
    return 0;
  }
MO.dump();
  llvm_unreachable("getMachineOpValue: Unable to encode MCOperand!");
}

uint32_t MSP430MCCodeEmitter::
getCCEncoding(const MCInst &MI, unsigned OpIdx,
              SmallVectorImpl<MCFixup> &Fixups,
              const MCSubtargetInfo &STI) const {

  const MCOperand &MO = MI.getOperand(OpIdx);
  if (MO.isImm()) return MO.getImm();
  llvm_unreachable("getCCEncoding: Unable to encode MCOperand!");
  return 0;
}

uint32_t MSP430MCCodeEmitter::
getPCRelImmOpEncoding(const MCInst &MI, unsigned OpIdx,
                      SmallVectorImpl<MCFixup> &Fixups,
                      const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpIdx);
  if (MO.isImm()) return (MO.getImm() >> 1);

  if (MO.isExpr()) {
    int64_t v;
    const MCExpr *Expr = MO.getExpr();
    if (Expr->evaluateAsAbsolute(v)) {
      return (uint32_t) v >> 1;
    }
    MCFixupKind Kind = (MCFixupKind)MSP430::FK_MSP430_10_PCREL;
    Fixups.push_back(MCFixup::create(0, Expr, Kind, MI.getLoc()));

    // All of the information is in the fixup.
    return 0;
  }

MO.dump();
if (!Fixups.empty()) {
for (auto &F : Fixups)
    dbgs() << format ("%d ",F.getKind());
dbgs() << "\n";
}

  llvm_unreachable("getPCRelImmOpEncoding: Unable to encode MCOperand!");
  return 0;
}

uint32_t MSP430MCCodeEmitter::
getMemOpEncoding(const MCInst &MI, unsigned OpIdx,
                 SmallVectorImpl<MCFixup> &Fixups,
                 const MCSubtargetInfo &STI) const {
//MI.dump();

  const MCOperand &MO = MI.getOperand(OpIdx);
  if (MO.isReg()) {
    unsigned Reg = MO.getReg();
    unsigned rval = Ctx.getRegisterInfo()->getEncodingValue(Reg) << 16;
    const MCOperand MOf = MI.getOperand(OpIdx+1);
    if (MOf.isImm()) return MOf.getImm() | rval;
MOf.dump();
  llvm_unreachable("getPCRelImmOpEncoding: Unable to encode MCOperand!");
  } else if (MO.isImm()) {
    return (MO.getImm());
  } else if (MO.isExpr()) {
    int64_t v;
    const MCExpr *Expr = MO.getExpr();
    if (Expr->evaluateAsAbsolute(v)) {
      return (uint32_t) v;
    }
    Fixups.push_back(MCFixup::create(0, Expr, FK_Data_2, MI.getLoc()));

    // All of the information is in the fixup.
    return 0;
  }

MO.dump();
if (!Fixups.empty()) {
for (auto &F : Fixups)
    dbgs() << format ("%d ",F.getKind());
dbgs() << "\n";
}

  llvm_unreachable("getPCRelImmOpEncoding: Unable to encode MCOperand!");
  return 0;
}

uint32_t MSP430MCCodeEmitter::
getR2R3ImmEncoding(const MCInst &MI, unsigned OpIdx,
                   SmallVectorImpl<MCFixup> &Fixups,
                   const MCSubtargetInfo &STI) const {

  const MCOperand &MO = MI.getOperand(OpIdx);
  if (MO.isImm()) {
    switch (MO.getImm()) {
    default: {
      dbgs() << format ("wasn't expecting %d\n",MO.getImm());
MI.dump();
      return 0;}
    case  0: return 0x03;
    case  1: return 0x13;
    case  2: return 0x23;
    case -1: return 0x33;
    case  4: return 0x22;
    case  8: return 0x32;
    }
  }
MO.dump();
  llvm_unreachable("getR2R3ImmEncoding: Unable to encode MCOperand!");
  return 0;
}

/// getRegInd: return a 6 bit field encoded <2> addr Mode <4> Reg #
uint32_t
MSP430MCCodeEmitter::getRegInd(const MCInst &MI, unsigned OpIdx,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const
{
  const MCOperand &Mr = MI.getOperand(OpIdx);
  const MCOperand &Mi = MI.getOperand(OpIdx+1);
  if (Mr.isReg() && Mi.isImm()) {
    uint32_t v = Mi.getImm();
    if (v == 2 || v == 3) {
      unsigned Reg = Mr.getReg();
      v <<= 4;
      v |= Ctx.getRegisterInfo()->getEncodingValue(Reg) & 0x0f;
      return v;
    }
  }
MI.dump();
Mr.dump();
  llvm_unreachable("getRegInd: Unable to encode MCOperand!");
  return 0;
}

#include "MSP430GenMCCodeEmitter.inc"
